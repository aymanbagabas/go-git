package pktline

import (
	"bytes"
	"io"
	"strings"
)

// ScannerOld provides a convenient interface for reading the payloads of a
// series of pkt-lines.  It takes an io.Reader providing the source,
// which then can be tokenized through repeated calls to the Scan
// method.
//
// After each Scan call, the Bytes method will return the payload of the
// corresponding pkt-line on a shared buffer, which will be 65516 bytes
// or smaller.  Flush pkt-lines are represented by empty byte slices.
//
// Scanning stops at EOF or the first I/O error.
type ScannerOld struct {
	r       io.Reader           // The reader provided by the client
	err     error               // Sticky error
	payload []byte              // Last pkt-payload
	len     [PacketLenSize]byte // Last pkt-len
}

// NewScannerOld returns a new Scanner to read from r.
func NewScannerOld(r io.Reader) *ScannerOld {
	return &ScannerOld{
		r: r,
	}
}

// Err returns the first error encountered by the ScannerOld.
func (s *ScannerOld) Err() error {
	return s.err
}

// Scan advances the ScannerOld to the next pkt-line, whose payload will
// then be available through the Bytes method.  Scanning stops at EOF
// or the first I/O error.  After Scan returns false, the Err method
// will return any error that occurred during scanning, except that if
// it was io.EOF, Err will return nil.
func (s *ScannerOld) Scan() bool {
	var l int
	l, s.err = s.readPayloadLen()
	if s.err == io.EOF {
		s.err = nil
		return false
	}
	if s.err != nil {
		return false
	}

	if cap(s.payload) < l {
		s.payload = make([]byte, 0, l)
	}

	if _, s.err = io.ReadFull(s.r, s.payload[:l]); s.err != nil {
		return false
	}
	s.payload = s.payload[:l]
	// trace.Packet.Printf("packet: < %04x %s", l, s.payload)

	if bytes.HasPrefix(s.payload, errPrefix) {
		s.err = &ErrorLine{
			Text: strings.TrimSpace(string(s.payload[4:])),
		}
		return false
	}

	return true
}

// Bytes returns the most recent payload generated by a call to Scan.
// The underlying array may point to data that will be overwritten by a
// subsequent call to Scan. It does no allocation.
func (s *ScannerOld) Bytes() []byte {
	return s.payload
}

// Method readPayloadLen returns the payload length by reading the
// pkt-len and subtracting the pkt-len size.
func (s *ScannerOld) readPayloadLen() (int, error) {
	if _, err := io.ReadFull(s.r, s.len[:]); err != nil {
		if err == io.ErrUnexpectedEOF {
			return 0, ErrInvalidPktLen
		}

		return 0, err
	}

	n, err := hexDecode(s.len[:])
	if err != nil {
		return 0, err
	}

	switch {
	case n == 0:
		return 0, nil
	case n <= PacketLenSize:
		return 0, ErrInvalidPktLen
	case n > MaxPayloadSize+PacketLenSize:
		return 0, ErrInvalidPktLen
	default:
		return n - PacketLenSize, nil
	}
}
